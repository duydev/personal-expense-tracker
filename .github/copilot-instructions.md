## Copilot / AI agent quick instructions — Personal Expense Tracker

This file captures the concrete, discoverable patterns an AI coding agent should know to be productive in this monorepo.

- Repo layout: top-level Yarn workspaces. Packages live under `packages/`:
  - `packages/api` — NestJS backend (TypeORM + PostgreSQL). Entry: `packages/api/src/main.ts`.
  - `packages/frontend` — React + Vite frontend. Entry: `packages/frontend/src/main.tsx`.

- Quick commands (root):
  - Install: `yarn install` (this is a Yarn workspace monorepo).
  - Dev API: `yarn dev:api` → runs `yarn workspace api start:dev` (see `packages/api/package.json`).
  - Dev frontend: `yarn dev:frontend` → runs Vite dev server.
  - Build API: `yarn build:api` ; Build frontend: `yarn build:frontend`.

- Important runtime/config notes:
  - The API reads configuration from environment variables via `@nestjs/config`. Check `packages/api/src/app.module.ts` for DB and rate-limit wiring.
  - TypeORM is configured with `synchronize: true` in `AppModule` (development convenience). Do NOT assume this is safe for production; set `synchronize: false` and use migrations for prod.
  - Swagger UI is mounted at `/api` (see `packages/api/src/main.ts`).

- Key endpoints and modules (use as examples when adding features):
  - Health: `GET /health` — controller in `packages/api/src/health/health.controller.ts`.
  - Users module: controller/service/entity scaffolding under `packages/api/src/users/` (see `users.controller.ts`, `users.service.ts`, `entities/user.entity.ts`).

- Project-specific coding patterns and conventions:
  - NestJS modular structure: add a new feature as a module under `packages/api/src/<feature>` with `module`, `controller`, `service`, `dto/` and `entities/` folders.
  - TypeORM repositories are injected with `@InjectRepository(Entity)` (see `UsersService`).
  - Global pipes/guards/interceptors are registered in `AppModule` using `provide: 'APP_PIPE'`, `APP_GUARD`, and `APP_INTERCEPTOR`. Validation uses `ValidationPipe({ whitelist: true, forbidNonWhitelisted: true })` — when creating DTOs, prefer `class-validator` decorators to match this behaviour.
  - Rate limiting is applied via `@nestjs/throttler` as a global guard. Look at `AppModule` for TTL/limit sourcing from env.

- Tests and CI:
  - Unit tests: `yarn workspace api test` (Jest configured in `packages/api/package.json`).
  - E2E tests: `yarn workspace api test:e2e` (see `packages/api/test/jest-e2e.json`).
  - Frontend has no test scripts in package.json; focus on manual/visual checks or add tests under `packages/frontend/src` if required.

- When touching both API and frontend:
  - Use the monorepo scripts (`yarn dev:api`, `yarn dev:frontend`) to run both concurrently in separate terminals.
  - Frontend expects the API to be available (configure CORS via `WHITELISTED_DOMAINS` env or run in development where CORS may be permissive).

- Small code examples to follow existing style:
  - Add a controller: use `@Controller('X')` and export a class in `packages/api/src/<feature>/<feature>.controller.ts` (see `health.controller.ts`).
  - Use services for business logic and inject repositories in services (see `UsersService`).
  - Place DB entities in `packages/api/src/<feature>/entities/` and register them via `TypeOrmModule.forFeature([Entity])` in the module file.

- Safety and verification checklist for PRs generated by an AI:
  1. Run `yarn install` and the relevant dev servers locally.

2.  Run `yarn workspace api test` and `yarn workspace api test:e2e` where appropriate.
3.  Verify Swagger at `http://localhost:3000/api` (default port) and `GET /health` returns the expected shape.
4.  Ensure no new TypeORM `synchronize`-only behaviors are relied upon for production data migrations.

- Where to start when asked to implement a feature:
  1. Read `README.md` (root) and `packages/api/src/main.ts` + `packages/api/src/app.module.ts` for global app wiring.

2.  Inspect nearby modules for patterns (e.g., `packages/api/src/users/`).
3.  Add DTOs under `dto/` and entities under `entities/` and wire the module in `app.module.ts` or via lazy-loading pattern if present.

If anything in this file is unclear or you need more examples (typical DTOs, entity fields, or test patterns), tell me which area and I will expand with concise, discoverable snippets from the repo.
